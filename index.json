[{"categories":["macOS","Apple","python"],"content":"With the announcement at Catalina’s release that some third party run times will be removed, and the fact that Python 2 is end of life it is time to ship your own. Just like everything in tech, there are many ways to accomplish this. I have been using a tool for about over a year now called relocatable python. The reasons I chose to use relocatable python were pretty good ones in my opinion. They are: Easy to use Builds full self contained Python environment Easily able to wrap it up in a standard installer PKG Once you have it in an installer package, you can use whatever tools you want to distribute it. Every management tool and application deployment tool should be able to deploy an installer pkg. quick start guide Download the repo from the link above from the directory you wish to download it to git clone https://github.com/gregneagle/relocatable-python.git Look at the --help argument to see what we can do. Ensure you are in the repo folder. % ./make_relocatable_python_framework.py --help Usage: make_relocatable_python_framework.py [options] Options: -h, --help show this help message and exit --destination=DESTINATION Directory destination for the Python.framework --baseurl=BASEURL Override the base URL used to download the framework. --os-version=OS_VERSION Override the macOS version of the downloaded pkg. Current supported versions are \"10.6\" and \"10.9\". Not all Python version and macOS version combinations are valid. --python-version=PYTHON_VERSION Override the version of the Python framework to be downloaded. See available versions at https://www.python.org/downloads/mac-osx/ --pip-requirements=PIP_REQUIREMENTS Path to a pip freeze requirements.txt file that describes extra Python modules to be installed. If not provided, certain useful modules for macOS will be installed. Lets make the folders where we want to create our Python environment % sudo mkdir -p /usr/local/acme/ /usr/local/acme/bin Note: I made two directories there and will explain later why. You can put this anywhere you want. In this example I am using /usr/local but if you want it away from user space you can place it in say something like /opt Now lets build our first Relocatable Python Package sudo ./make_relocatable_python_framework.py --destination=/usr/local/acme --python-version=3.8.5 Note: you will see the tool output a bunch fo stuff in the terminal, let it finish No we will create our symbolic link to make this easier when we want to call this environment in code # go to the bin folder we created cd /usr/local/acme/bin # create a symbolic link to our new framework sudo ln -s /usr/local/acme/Python.framework/Versions/3.8/bin/python3 python3 # now test it ./python3 Python 3.8.5 (v3.8.5:580fbb018f, Jul 20 2020, 12:11:27) [Clang 6.0 (clang-600.0.57)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. # exit when you are done \u003e\u003e\u003e exit() Now you just need to use your preferred packaging tool to add this folder path, including the symbolic link in an Apple Installer Package. ","date":"2020-09-20","objectID":"/posts/shipping-python/:0:0","tags":["macOS","python","python3"],"title":"Shipping Your Own Python to macOS","uri":"/posts/shipping-python/"},{"categories":["macOS","Apple","python"],"content":"Caveats, and things to consider As XKCD has already pointed out, managing a Python Environment can be a chore Installation Path In the above example there are definitely some things to know and consider. To keep the quick start guide less esoteric I just used /usr/local as the directory to deploy my Python 3 environment into. In practice, I actually do not do this. I deploy to /opt/myorg instead to my fleet. I have worked with lots of clever developers over the years, and they need to often install tools to do their job. Those tools often go into /usr/local, thus I stay out of that area. I let user’s have that space to themselves. Which Python? I also have Xcode on this Mac, and I also installed the Python3 Xcode tools as well. % which python3 /usr/bin/python3 When you install that, it does put python3 in the standard $PATH and if your code calls that path or if you just type python3 in the shell, without typing the full path, you will get that Python environment. Some planning will be needed as well as some decision-making by the IT Admin/Engineer that wants to deploy their own Python. Ther is no gold standard answer, so you will need to figure out what is the best answer for your team and Org. Requirements.txt file The author of Relocatable Python did something clever, but some may have missed it. They made an assumption that if you were to build a Python3 environment to deploy to your macOS fleet you might want the objc bridge, and tools like xattr So, those tools are just included in the default argument. You should note this just in case you plan on customizing your Python3 package to add more Python packages to it. You will need to add those back. One can view the documentation on how this works. To see what packages you have you can use pip to do so: % cd /usr/local/acme/Python.framework/Versions/3.8/bin % ./pip3 list This will output a giant list of packages you have installed. If you want to add more packages you should also include the ones the author of Relocatable Python gave you. When using a requirements.txt file it strictly follows that file. Anything not listed will not get installed. Refer to the --help output we used earlier to add the requirements.txt file sudo ./make_relocatable_python_framework.py --destination=/usr/local/acme --python-version=3.8.5 --pip-requirements=/path/to/requirements.txt Mac Admin Community Python There also those in the Mac Admin community who are already maintaining a public Python3 package which anyone can just go download and/or contribute to. You can find the repo here. This method does make design choices for you. If these design choices are okay with you, then this would be the easiest and fastest way to just ship your own Python3 environment to your fleet. Virtual Environments This is also an option, but it seems most Orgs want to ship their own isolated Ptyhon and if they need to create a venv they can do so from the Python they have shipped. Personally, I hae never used a venv outside of my on personal development. I chose to ship the environments, so I can control it. If you want to control venv to a fleet I think shipping your own is the best to start and then build your venv off of that. ","date":"2020-09-20","objectID":"/posts/shipping-python/:0:1","tags":["macOS","python","python3"],"title":"Shipping Your Own Python to macOS","uri":"/posts/shipping-python/"},{"categories":["macOS","Apple","python"],"content":"Tracking Versions, upgrades, and remediation I think in the past ~2 years I have found 2-4 systems total that had bad Python environments I was shipping. I am not exactly sure why they broke, it could have just been a failed install. So, I started tracking the status and version I was shipping in a simple Jamf EA. Here is a quick example I wrote in the shell: if results=$(/usr/local/acme/bin/python3 -V | awk '{ print $2 }') if\u003e then echo \"\u003cresult\u003e${results}\u003c/result\u003e\" then\u003e else echo \"\u003cresult\u003efalse\u003c/result\u003e\" else\u003e fi \u003cresult\u003e3.8.5\u003c/result\u003e This script will return a false value for any broken Python environment. So, I have an ongoing policy that will reinstall my Python3 environment scoped to this EA with a value of false so this is intentional. I highly recommend you never use blank values in anything you use. Always be explicit with your data, you will never now what a null or blank string value will affect, down or up stream. ","date":"2020-09-20","objectID":"/posts/shipping-python/:0:2","tags":["macOS","python","python3"],"title":"Shipping Your Own Python to macOS","uri":"/posts/shipping-python/"},{"categories":["macOS","Apple","python"],"content":"Conclusion and acknowledgements You have many options to choose from. This is not too difficult as I have been doing this for coming up on 2 years now. If I can do this, so can everyone else. Acknowledgements: Greg Neagle Mac Admins Slack Mac Admin Community ","date":"2020-09-20","objectID":"/posts/shipping-python/:0:3","tags":["macOS","python","python3"],"title":"Shipping Your Own Python to macOS","uri":"/posts/shipping-python/"},{"categories":["webhooks","jamf","snowflake"],"content":"Shipping Jamf Pro Webhooks to Snowflake Jamf Pro has a builtin feature where you have the ability to ship a webhook event when specific events happen in their application. This allows for a near real time feed of event based data which you can consume and leverage to gain insights about your fleet. Jamf provides some documentation online, found here. Webhooks are generated automatically, and near instantly when an event occurs. In the linked documentation above you will see all the possible webhooks and sample data of what each webhook ships. There are many ways to ship webhooks, and you can choose from many paths to take. You can roll your own webhook receiver, you can ship webhooks directly to cloud storage (S3, Azure Blob, GCP Cloud Storage), use one of many data ingestion tools, and so forth. Right now we are leveraging a tool called Fivetran. Fivetran has built in integration to many SaaS and cloud services. What tools work best for your Organization will be up to your Org to decide. Here is how the data flow looks: First we need to configure Fivetran Snowflake Connector After that create the database in Snowflake, for reference here is the documentation This blog post assumes you have this operating and working, as every Org might have different configurations or requirements in their apps, please refer to the official documentation to ensure this is working. With in Snowflake you can have many warehouses, databases, schemas, and a wide range of RBAC controls in place. So, you may need to adjust some knobs to get this to work. Here is what I have created in my dev account: If you have your database setup now we need to log into Fivetran and create our connector. Find the Webhook Conector with in Fivetran and create a new one. You will want to make sure you already have the database in place and Fivetran has the proper RBAC on that table for data ingestion. Here is an example: There will be a Webhook URL once created which you will need to configure in the Jamf Pro Server. Navigate to Settings \u003e Global Management \u003e Webhooks. Create a new webhook, select the event you want to ship (above example was ComputerCheckin), and make sure you select JSON as the data type. Input the URL you generated in Fivetran and any other options you would like to tweak. You can see that I have my schema set and the table set that matches my dev account in the screenshots. For reference: In Fivetran you can select how often data synchronizes with Snowflake. Since Webhooks are event based data, it is my opinion that the faster you can consume the event, the more valuable that data is. So, I have chosen to ingest every 5 minutes. If you want to pick a different time, you may do so. Your Org may have different needs or requirements, but I do strongly suggest you ingest the webhooks as fast as you can. For example, if you are building data around events, the event based data is more valuable if you can get it in near-realtime. Below are the settings I have configured. So that is it! Just repeat this process for each webhook event you wish to ship to Snowflake. Now you can let the data flow right in, and you are ready to query some of the data and get intelligence off of it. Now for some fun. If you want to find out how many times a specific Policy ID has ran on your fleet with in a specific time frame you can do this quite easily. Since Snowflake is highly scalable and allows one to store massive amounts of data you can keep all your historic data as you see fit. Here is an example query: ALTER SESSION SET TIMEZONE = 'UTC'; select count(*), EVENT:policyId as policy_id , EVENT:computer.jssID as jss_id , EVENT:successful as state from \"JAMF_EVENTSDB\".\"JAMF_EVENTS\".\"POLICIES\" where policy_id = '256' and TO_TIMESTAMP(WEBHOOK:eventTimestamp::INTEGER/1000) \u003e dateadd(days, -1, current_timestamp()) group by state, policy_id, jss_id; NOTE: Jamf Pro Webhooks ship with UTC millisecond epoch time stamps COUNT(*) POLICY_ID JSS_ID STATE 2 256 2240 true In the ab","date":"2020-09-19","objectID":"/posts/shipping-jamf-webhooks/:0:0","tags":["data","webhooks","fivetran","jamf","snowflake"],"title":"Shipping Jamf Webhooks with Fivetran","uri":"/posts/shipping-jamf-webhooks/"},{"categories":["data sharing","snowflake"],"content":"Data Sharing is Data Caring ❤️ I have come to the conclusion that there are essentially two types of people when it comes to data. The people that have data, and the people that wish they had the data. Another thought is that I would rather have the data and not need it versus need the data and not have it. For almost the past two years I have had the privilege to work for a great data platform company. The amount of data we have access to increases our return on what we do in the IT/Ops space exponentially. It also helps drive collaboration between teams, allows for centralized data sharing, and enables everyone to make data driven decisions. In a previous life I did have some opportunity to work with various data tools, and use data to help me accomplish my goals. However, I have never had data like I do now. When I worked in vendor space a lot of my exposure to data tools was around what our customer’s wanted. Many of the customers I engaged with wanted to get all their data from my employer’s product. This typically resulted in large projects, and many labor hours to accomplish. There were also almost always caveats with most of the tools we were using that made us make hard decisions. At one previous job I did have more direct exposure and responsibility around a data tool. It took me four to six weeks to get our test instance setup. I had to configure TLS communication for the elastic cluster. Generate certificates, which was a trial by fire process. Then setup the filebeat \u003e logstash \u003e elastic pipeline. At the Logstash level you had to grok your data and create multiple indices, so you were shaping the data before ingesting it. This had a pretty high learning curve and took a lot of time and effort to just proof of concept. Do not get me wrong here, I do think Elastic is a great tool. When I first showed up at Snowflake, I honestly did not know too much about the product other than the basic PR stuff that I had read online, some blog posts, and some Internet posts on various sites. When I wanted to ship webhooks from our MDM solution, I got access to our Fivetran Instance and with in 30-45 minutes of looking at some documentation and tinkering in my dev environment I had webhooks shipping. I could not believe it took me under a hour to figure this out. I was prepared for it to take weeks from previous experiences. One can also just ship the raw data. No need to grok, no need to transform my data before ingesting it, and I have all of it. Enter Data Sharing ❄️ All of our business units ship their data to our data platform. So, every department has their own database, with their own schemas, and their own tables containing all the data they need access to. Since Snowflake’s data platform allows one to have as many databases, warehouses, tables, views, schemas and so forth as they see fit, it allows for easy data sharing. This means we can all share data to each other, and only the data we want to share. All of the data is on the same platform, so you aren’t spinning up a plethora of servers and then configuring them to access each other. The return you get on saved time and labor is already worth it. In the past, I dealt with gatekeepers of data. I was a data gatekeeper myself. IT and Security typically work with each other at most Organizations. Their goals often align with what the business wants. So, to get data you had to deal with each gatekeeper of each system. IT/Ops and Security typically own several systems if not more on each side. Often you would end up with the data gatekeeper emailing you a spreadsheet of the data you requested. If you were lucky you got API access to consume the data on your own. This is not a good experience, and it was definitely not efficient. With Snowflake, we can freely share data between IT/Ops and Security. When the raw data is updated from ingest, all the data shares among our teams is also updated. There is no more always dealing with a gatekeeper and getting a spreadsheet emailed ","date":"2020-09-19","objectID":"/posts/data-sharing/:0:0","tags":["data sharing","snowflake"],"title":"Data Sharing","uri":"/posts/data-sharing/"}]